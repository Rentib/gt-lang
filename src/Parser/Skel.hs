-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Parser.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Parser.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: Parser.Abs.Ident -> Result
transIdent x = case x of
  Parser.Abs.Ident string -> failure x

transTranslationUnit :: Show a => Parser.Abs.TranslationUnit' a -> Result
transTranslationUnit x = case x of
  Parser.Abs.Program _ decls -> failure x

transType :: Show a => Parser.Abs.Type' a -> Result
transType x = case x of
  Parser.Abs.TInt _ -> failure x
  Parser.Abs.TBool _ -> failure x
  Parser.Abs.TChar _ -> failure x
  Parser.Abs.TVoid _ -> failure x
  Parser.Abs.TConst _ type_ -> failure x
  Parser.Abs.TFunc _ types type_ -> failure x
  Parser.Abs.TArray _ type_ -> failure x

transArg :: Show a => Parser.Abs.Arg' a -> Result
transArg x = case x of
  Parser.Abs.PArgVal _ ident type_ -> failure x
  Parser.Abs.PArgRef _ ident type_ -> failure x

transBlock :: Show a => Parser.Abs.Block' a -> Result
transBlock x = case x of
  Parser.Abs.PBlock _ decls instrs -> failure x

transDecl :: Show a => Parser.Abs.Decl' a -> Result
transDecl x = case x of
  Parser.Abs.DVar _ ditems -> failure x
  Parser.Abs.DConst _ ditemconsts -> failure x
  Parser.Abs.DFunc _ ident args type_ block -> failure x

transDItem :: Show a => Parser.Abs.DItem' a -> Result
transDItem x = case x of
  Parser.Abs.DItemNoInit _ ident type_ -> failure x
  Parser.Abs.DItemInit _ ident expr -> failure x

transDItemConst :: Show a => Parser.Abs.DItemConst' a -> Result
transDItemConst x = case x of
  Parser.Abs.DItemConstInit _ ident expr -> failure x

transInstr :: Show a => Parser.Abs.Instr' a -> Result
transInstr x = case x of
  Parser.Abs.IBlock _ block -> failure x
  Parser.Abs.IExpr _ expr -> failure x
  Parser.Abs.IIf _ expr instr -> failure x
  Parser.Abs.IIfElse _ expr instr1 instr2 -> failure x
  Parser.Abs.IWhile _ expr instr -> failure x
  Parser.Abs.IFor _ expr1 expr2 expr3 instr -> failure x
  Parser.Abs.IContinue _ -> failure x
  Parser.Abs.IBreak _ -> failure x
  Parser.Abs.IReturn _ expr -> failure x

transExpr :: Show a => Parser.Abs.Expr' a -> Result
transExpr x = case x of
  Parser.Abs.ELitInt _ integer -> failure x
  Parser.Abs.ELitChar _ char -> failure x
  Parser.Abs.ELitString _ string -> failure x
  Parser.Abs.ELitTrue _ -> failure x
  Parser.Abs.ELitFalse _ -> failure x
  Parser.Abs.EIdent _ ident -> failure x
  Parser.Abs.EIndex _ expr1 expr2 -> failure x
  Parser.Abs.EApply _ expr exprs -> failure x
  Parser.Abs.ECast _ type_ expr -> failure x
  Parser.Abs.EUOp _ unaryop expr -> failure x
  Parser.Abs.EMul _ expr1 mulop expr2 -> failure x
  Parser.Abs.EAdd _ expr1 addop expr2 -> failure x
  Parser.Abs.ERel _ expr1 relop expr2 -> failure x
  Parser.Abs.EEq _ expr1 eqop expr2 -> failure x
  Parser.Abs.EAnd _ expr1 expr2 -> failure x
  Parser.Abs.EOr _ expr1 expr2 -> failure x
  Parser.Abs.EAssign _ expr1 assignop expr2 -> failure x
  Parser.Abs.ELambda _ args type_ block -> failure x
  Parser.Abs.EEmpty _ -> failure x

transUnaryOp :: Show a => Parser.Abs.UnaryOp' a -> Result
transUnaryOp x = case x of
  Parser.Abs.OpUnaryPlus _ -> failure x
  Parser.Abs.OpUnaryMinus _ -> failure x
  Parser.Abs.OpUnaryBang _ -> failure x

transMulOp :: Show a => Parser.Abs.MulOp' a -> Result
transMulOp x = case x of
  Parser.Abs.OpTimes _ -> failure x
  Parser.Abs.OpDiv _ -> failure x
  Parser.Abs.OpMod _ -> failure x

transAddOp :: Show a => Parser.Abs.AddOp' a -> Result
transAddOp x = case x of
  Parser.Abs.OpPlus _ -> failure x
  Parser.Abs.OpMinus _ -> failure x

transRelOp :: Show a => Parser.Abs.RelOp' a -> Result
transRelOp x = case x of
  Parser.Abs.OpLT _ -> failure x
  Parser.Abs.OpLE _ -> failure x
  Parser.Abs.OpGT _ -> failure x
  Parser.Abs.OpGE _ -> failure x

transEqOp :: Show a => Parser.Abs.EqOp' a -> Result
transEqOp x = case x of
  Parser.Abs.OpEq _ -> failure x
  Parser.Abs.OpNeq _ -> failure x

transAssignOp :: Show a => Parser.Abs.AssignOp' a -> Result
transAssignOp x = case x of
  Parser.Abs.OpAssign _ -> failure x
